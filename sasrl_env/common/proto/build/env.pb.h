// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: env.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_env_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_env_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_env_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_env_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_env_2eproto;
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class EnvSeed;
struct EnvSeedDefaultTypeInternal;
extern EnvSeedDefaultTypeInternal _EnvSeed_default_instance_;
class Info;
struct InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class MetaData;
struct MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class Name;
struct NameDefaultTypeInternal;
extern NameDefaultTypeInternal _Name_default_instance_;
class Observation;
struct ObservationDefaultTypeInternal;
extern ObservationDefaultTypeInternal _Observation_default_instance_;
class RenderMode;
struct RenderModeDefaultTypeInternal;
extern RenderModeDefaultTypeInternal _RenderMode_default_instance_;
class RenderOut;
struct RenderOutDefaultTypeInternal;
extern RenderOutDefaultTypeInternal _RenderOut_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class Space;
struct SpaceDefaultTypeInternal;
extern SpaceDefaultTypeInternal _Space_default_instance_;
class StepInfo;
struct StepInfoDefaultTypeInternal;
extern StepInfoDefaultTypeInternal _StepInfo_default_instance_;
class StepInfoKV;
struct StepInfoKVDefaultTypeInternal;
extern StepInfoKVDefaultTypeInternal _StepInfoKV_default_instance_;
class StepInfoKVBool;
struct StepInfoKVBoolDefaultTypeInternal;
extern StepInfoKVBoolDefaultTypeInternal _StepInfoKVBool_default_instance_;
class StepInfoKVFloat;
struct StepInfoKVFloatDefaultTypeInternal;
extern StepInfoKVFloatDefaultTypeInternal _StepInfoKVFloat_default_instance_;
class StepInfoKVInt;
struct StepInfoKVIntDefaultTypeInternal;
extern StepInfoKVIntDefaultTypeInternal _StepInfoKVInt_default_instance_;
class StepInfoKVString;
struct StepInfoKVStringDefaultTypeInternal;
extern StepInfoKVStringDefaultTypeInternal _StepInfoKVString_default_instance_;
class StepInfoKV_BMapEntry_DoNotUse;
struct StepInfoKV_BMapEntry_DoNotUseDefaultTypeInternal;
extern StepInfoKV_BMapEntry_DoNotUseDefaultTypeInternal _StepInfoKV_BMapEntry_DoNotUse_default_instance_;
class StepInfoKV_FMapEntry_DoNotUse;
struct StepInfoKV_FMapEntry_DoNotUseDefaultTypeInternal;
extern StepInfoKV_FMapEntry_DoNotUseDefaultTypeInternal _StepInfoKV_FMapEntry_DoNotUse_default_instance_;
class StepInfoKV_IMapEntry_DoNotUse;
struct StepInfoKV_IMapEntry_DoNotUseDefaultTypeInternal;
extern StepInfoKV_IMapEntry_DoNotUseDefaultTypeInternal _StepInfoKV_IMapEntry_DoNotUse_default_instance_;
class StepInfoKV_SMapEntry_DoNotUse;
struct StepInfoKV_SMapEntry_DoNotUseDefaultTypeInternal;
extern StepInfoKV_SMapEntry_DoNotUseDefaultTypeInternal _StepInfoKV_SMapEntry_DoNotUse_default_instance_;
class Transition;
struct TransitionDefaultTypeInternal;
extern TransitionDefaultTypeInternal _Transition_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Action* Arena::CreateMaybeMessage<::Action>(Arena*);
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::EnvSeed* Arena::CreateMaybeMessage<::EnvSeed>(Arena*);
template<> ::Info* Arena::CreateMaybeMessage<::Info>(Arena*);
template<> ::MetaData* Arena::CreateMaybeMessage<::MetaData>(Arena*);
template<> ::Name* Arena::CreateMaybeMessage<::Name>(Arena*);
template<> ::Observation* Arena::CreateMaybeMessage<::Observation>(Arena*);
template<> ::RenderMode* Arena::CreateMaybeMessage<::RenderMode>(Arena*);
template<> ::RenderOut* Arena::CreateMaybeMessage<::RenderOut>(Arena*);
template<> ::ServerInfo* Arena::CreateMaybeMessage<::ServerInfo>(Arena*);
template<> ::Space* Arena::CreateMaybeMessage<::Space>(Arena*);
template<> ::StepInfo* Arena::CreateMaybeMessage<::StepInfo>(Arena*);
template<> ::StepInfoKV* Arena::CreateMaybeMessage<::StepInfoKV>(Arena*);
template<> ::StepInfoKVBool* Arena::CreateMaybeMessage<::StepInfoKVBool>(Arena*);
template<> ::StepInfoKVFloat* Arena::CreateMaybeMessage<::StepInfoKVFloat>(Arena*);
template<> ::StepInfoKVInt* Arena::CreateMaybeMessage<::StepInfoKVInt>(Arena*);
template<> ::StepInfoKVString* Arena::CreateMaybeMessage<::StepInfoKVString>(Arena*);
template<> ::StepInfoKV_BMapEntry_DoNotUse* Arena::CreateMaybeMessage<::StepInfoKV_BMapEntry_DoNotUse>(Arena*);
template<> ::StepInfoKV_FMapEntry_DoNotUse* Arena::CreateMaybeMessage<::StepInfoKV_FMapEntry_DoNotUse>(Arena*);
template<> ::StepInfoKV_IMapEntry_DoNotUse* Arena::CreateMaybeMessage<::StepInfoKV_IMapEntry_DoNotUse>(Arena*);
template<> ::StepInfoKV_SMapEntry_DoNotUse* Arena::CreateMaybeMessage<::StepInfoKV_SMapEntry_DoNotUse>(Arena*);
template<> ::Transition* Arena::CreateMaybeMessage<::Transition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerInfo& from) {
    ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class MetaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MetaData) */ {
 public:
  inline MetaData() : MetaData(nullptr) {}
  ~MetaData() override;
  explicit PROTOBUF_CONSTEXPR MetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaData(const MetaData& from);
  MetaData(MetaData&& from) noexcept
    : MetaData() {
    *this = ::std::move(from);
  }

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaData& operator=(MetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MetaData& a, MetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetaData& from) {
    MetaData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MetaData";
  }
  protected:
  explicit MetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvVersionFieldNumber = 1,
  };
  // string EnvVersion = 1;
  void clear_envversion();
  const std::string& envversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_envversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_envversion();
  PROTOBUF_NODISCARD std::string* release_envversion();
  void set_allocated_envversion(std::string* envversion);
  private:
  const std::string& _internal_envversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_envversion(const std::string& value);
  std::string* _internal_mutable_envversion();
  public:

  // @@protoc_insertion_point(class_scope:MetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr envversion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Name final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Name) */ {
 public:
  inline Name() : Name(nullptr) {}
  ~Name() override;
  explicit PROTOBUF_CONSTEXPR Name(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Name(const Name& from);
  Name(Name&& from) noexcept
    : Name() {
    *this = ::std::move(from);
  }

  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }
  inline Name& operator=(Name&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Name& default_instance() {
    return *internal_default_instance();
  }
  static inline const Name* internal_default_instance() {
    return reinterpret_cast<const Name*>(
               &_Name_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Name& a, Name& b) {
    a.Swap(&b);
  }
  inline void Swap(Name* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Name* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Name* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Name>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Name& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Name& from) {
    Name::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Name* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Name";
  }
  protected:
  explicit Name(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWrapperFieldNumber = 2,
    kDataFieldNumber = 1,
    kRenderModeFieldNumber = 3,
  };
  // repeated string wrapper = 2;
  int wrapper_size() const;
  private:
  int _internal_wrapper_size() const;
  public:
  void clear_wrapper();
  const std::string& wrapper(int index) const;
  std::string* mutable_wrapper(int index);
  void set_wrapper(int index, const std::string& value);
  void set_wrapper(int index, std::string&& value);
  void set_wrapper(int index, const char* value);
  void set_wrapper(int index, const char* value, size_t size);
  std::string* add_wrapper();
  void add_wrapper(const std::string& value);
  void add_wrapper(std::string&& value);
  void add_wrapper(const char* value);
  void add_wrapper(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wrapper() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wrapper();
  private:
  const std::string& _internal_wrapper(int index) const;
  std::string* _internal_add_wrapper();
  public:

  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string render_mode = 3;
  void clear_render_mode();
  const std::string& render_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_render_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_render_mode();
  PROTOBUF_NODISCARD std::string* release_render_mode();
  void set_allocated_render_mode(std::string* render_mode);
  private:
  const std::string& _internal_render_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_render_mode(const std::string& value);
  std::string* _internal_mutable_render_mode();
  public:

  // @@protoc_insertion_point(class_scope:Name)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wrapper_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr render_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  explicit PROTOBUF_CONSTEXPR Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Info& from) {
    Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservationSpaceFieldNumber = 1,
    kActionSpaceFieldNumber = 2,
    kMaxEpisodeStepsFieldNumber = 3,
  };
  // repeated .Space observation_space = 1;
  int observation_space_size() const;
  private:
  int _internal_observation_space_size() const;
  public:
  void clear_observation_space();
  ::Space* mutable_observation_space(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >*
      mutable_observation_space();
  private:
  const ::Space& _internal_observation_space(int index) const;
  ::Space* _internal_add_observation_space();
  public:
  const ::Space& observation_space(int index) const;
  ::Space* add_observation_space();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >&
      observation_space() const;

  // repeated .Space action_space = 2;
  int action_space_size() const;
  private:
  int _internal_action_space_size() const;
  public:
  void clear_action_space();
  ::Space* mutable_action_space(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >*
      mutable_action_space();
  private:
  const ::Space& _internal_action_space(int index) const;
  ::Space* _internal_add_action_space();
  public:
  const ::Space& action_space(int index) const;
  ::Space* add_action_space();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >&
      action_space() const;

  // int32 max_episode_steps = 3;
  void clear_max_episode_steps();
  int32_t max_episode_steps() const;
  void set_max_episode_steps(int32_t value);
  private:
  int32_t _internal_max_episode_steps() const;
  void _internal_set_max_episode_steps(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space > observation_space_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space > action_space_;
    int32_t max_episode_steps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfoKV_SMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_SMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_SMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StepInfoKV_SMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StepInfoKV_SMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StepInfoKV_SMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StepInfoKV_SMapEntry_DoNotUse& other);
  static const StepInfoKV_SMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StepInfoKV_SMapEntry_DoNotUse*>(&_StepInfoKV_SMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StepInfoKV.SMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StepInfoKV.SMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_env_2eproto;
};

// -------------------------------------------------------------------

class StepInfoKV_IMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_IMapEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_IMapEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  StepInfoKV_IMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StepInfoKV_IMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StepInfoKV_IMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StepInfoKV_IMapEntry_DoNotUse& other);
  static const StepInfoKV_IMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StepInfoKV_IMapEntry_DoNotUse*>(&_StepInfoKV_IMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StepInfoKV.IMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_env_2eproto;
};

// -------------------------------------------------------------------

class StepInfoKV_FMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_FMapEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_FMapEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> SuperType;
  StepInfoKV_FMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StepInfoKV_FMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StepInfoKV_FMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StepInfoKV_FMapEntry_DoNotUse& other);
  static const StepInfoKV_FMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StepInfoKV_FMapEntry_DoNotUse*>(&_StepInfoKV_FMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StepInfoKV.FMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_env_2eproto;
};

// -------------------------------------------------------------------

class StepInfoKV_BMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_BMapEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StepInfoKV_BMapEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  StepInfoKV_BMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR StepInfoKV_BMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StepInfoKV_BMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StepInfoKV_BMapEntry_DoNotUse& other);
  static const StepInfoKV_BMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StepInfoKV_BMapEntry_DoNotUse*>(&_StepInfoKV_BMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "StepInfoKV.BMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_env_2eproto;
};

// -------------------------------------------------------------------

class StepInfoKV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfoKV) */ {
 public:
  inline StepInfoKV() : StepInfoKV(nullptr) {}
  ~StepInfoKV() override;
  explicit PROTOBUF_CONSTEXPR StepInfoKV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfoKV(const StepInfoKV& from);
  StepInfoKV(StepInfoKV&& from) noexcept
    : StepInfoKV() {
    *this = ::std::move(from);
  }

  inline StepInfoKV& operator=(const StepInfoKV& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfoKV& operator=(StepInfoKV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfoKV& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfoKV* internal_default_instance() {
    return reinterpret_cast<const StepInfoKV*>(
               &_StepInfoKV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StepInfoKV& a, StepInfoKV& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfoKV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfoKV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfoKV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfoKV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfoKV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfoKV& from) {
    StepInfoKV::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfoKV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfoKV";
  }
  protected:
  explicit StepInfoKV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSMapFieldNumber = 1,
    kIMapFieldNumber = 2,
    kFMapFieldNumber = 3,
    kBMapFieldNumber = 4,
  };
  // map<string, string> s_map = 1;
  int s_map_size() const;
  private:
  int _internal_s_map_size() const;
  public:
  void clear_s_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_s_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_s_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      s_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_s_map();

  // map<string, int32> i_map = 2;
  int i_map_size() const;
  private:
  int _internal_i_map_size() const;
  public:
  void clear_i_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      _internal_i_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      _internal_mutable_i_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      i_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      mutable_i_map();

  // map<string, float> f_map = 3;
  int f_map_size() const;
  private:
  int _internal_f_map_size() const;
  public:
  void clear_f_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      _internal_f_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      _internal_mutable_f_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      f_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      mutable_f_map();

  // map<string, bool> b_map = 4;
  int b_map_size() const;
  private:
  int _internal_b_map_size() const;
  public:
  void clear_b_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      _internal_b_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      _internal_mutable_b_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      b_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      mutable_b_map();

  // @@protoc_insertion_point(class_scope:StepInfoKV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StepInfoKV_SMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> s_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StepInfoKV_IMapEntry_DoNotUse,
        std::string, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> i_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StepInfoKV_FMapEntry_DoNotUse,
        std::string, float,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> f_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        StepInfoKV_BMapEntry_DoNotUse,
        std::string, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> b_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfoKVInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfoKVInt) */ {
 public:
  inline StepInfoKVInt() : StepInfoKVInt(nullptr) {}
  ~StepInfoKVInt() override;
  explicit PROTOBUF_CONSTEXPR StepInfoKVInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfoKVInt(const StepInfoKVInt& from);
  StepInfoKVInt(StepInfoKVInt&& from) noexcept
    : StepInfoKVInt() {
    *this = ::std::move(from);
  }

  inline StepInfoKVInt& operator=(const StepInfoKVInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfoKVInt& operator=(StepInfoKVInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfoKVInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfoKVInt* internal_default_instance() {
    return reinterpret_cast<const StepInfoKVInt*>(
               &_StepInfoKVInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StepInfoKVInt& a, StepInfoKVInt& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfoKVInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfoKVInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfoKVInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfoKVInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfoKVInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfoKVInt& from) {
    StepInfoKVInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfoKVInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfoKVInt";
  }
  protected:
  explicit StepInfoKVInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StepInfoKVInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfoKVString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfoKVString) */ {
 public:
  inline StepInfoKVString() : StepInfoKVString(nullptr) {}
  ~StepInfoKVString() override;
  explicit PROTOBUF_CONSTEXPR StepInfoKVString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfoKVString(const StepInfoKVString& from);
  StepInfoKVString(StepInfoKVString&& from) noexcept
    : StepInfoKVString() {
    *this = ::std::move(from);
  }

  inline StepInfoKVString& operator=(const StepInfoKVString& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfoKVString& operator=(StepInfoKVString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfoKVString& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfoKVString* internal_default_instance() {
    return reinterpret_cast<const StepInfoKVString*>(
               &_StepInfoKVString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StepInfoKVString& a, StepInfoKVString& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfoKVString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfoKVString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfoKVString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfoKVString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfoKVString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfoKVString& from) {
    StepInfoKVString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfoKVString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfoKVString";
  }
  protected:
  explicit StepInfoKVString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:StepInfoKVString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfoKVFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfoKVFloat) */ {
 public:
  inline StepInfoKVFloat() : StepInfoKVFloat(nullptr) {}
  ~StepInfoKVFloat() override;
  explicit PROTOBUF_CONSTEXPR StepInfoKVFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfoKVFloat(const StepInfoKVFloat& from);
  StepInfoKVFloat(StepInfoKVFloat&& from) noexcept
    : StepInfoKVFloat() {
    *this = ::std::move(from);
  }

  inline StepInfoKVFloat& operator=(const StepInfoKVFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfoKVFloat& operator=(StepInfoKVFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfoKVFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfoKVFloat* internal_default_instance() {
    return reinterpret_cast<const StepInfoKVFloat*>(
               &_StepInfoKVFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StepInfoKVFloat& a, StepInfoKVFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfoKVFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfoKVFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfoKVFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfoKVFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfoKVFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfoKVFloat& from) {
    StepInfoKVFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfoKVFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfoKVFloat";
  }
  protected:
  explicit StepInfoKVFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // float value = 2;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:StepInfoKVFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfoKVBool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfoKVBool) */ {
 public:
  inline StepInfoKVBool() : StepInfoKVBool(nullptr) {}
  ~StepInfoKVBool() override;
  explicit PROTOBUF_CONSTEXPR StepInfoKVBool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfoKVBool(const StepInfoKVBool& from);
  StepInfoKVBool(StepInfoKVBool&& from) noexcept
    : StepInfoKVBool() {
    *this = ::std::move(from);
  }

  inline StepInfoKVBool& operator=(const StepInfoKVBool& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfoKVBool& operator=(StepInfoKVBool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfoKVBool& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfoKVBool* internal_default_instance() {
    return reinterpret_cast<const StepInfoKVBool*>(
               &_StepInfoKVBool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StepInfoKVBool& a, StepInfoKVBool& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfoKVBool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfoKVBool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfoKVBool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfoKVBool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfoKVBool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfoKVBool& from) {
    StepInfoKVBool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfoKVBool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfoKVBool";
  }
  protected:
  explicit StepInfoKVBool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bool value = 2;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StepInfoKVBool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    bool value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class StepInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepInfo) */ {
 public:
  inline StepInfo() : StepInfo(nullptr) {}
  ~StepInfo() override;
  explicit PROTOBUF_CONSTEXPR StepInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepInfo(const StepInfo& from);
  StepInfo(StepInfo&& from) noexcept
    : StepInfo() {
    *this = ::std::move(from);
  }

  inline StepInfo& operator=(const StepInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepInfo& operator=(StepInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepInfo* internal_default_instance() {
    return reinterpret_cast<const StepInfo*>(
               &_StepInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StepInfo& a, StepInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StepInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepInfo& from) {
    StepInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepInfo";
  }
  protected:
  explicit StepInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIntFieldNumber = 1,
    kDataStrFieldNumber = 2,
    kDataFloatFieldNumber = 3,
    kDataBoolFieldNumber = 4,
  };
  // repeated .StepInfoKVInt data_int = 1;
  int data_int_size() const;
  private:
  int _internal_data_int_size() const;
  public:
  void clear_data_int();
  ::StepInfoKVInt* mutable_data_int(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVInt >*
      mutable_data_int();
  private:
  const ::StepInfoKVInt& _internal_data_int(int index) const;
  ::StepInfoKVInt* _internal_add_data_int();
  public:
  const ::StepInfoKVInt& data_int(int index) const;
  ::StepInfoKVInt* add_data_int();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVInt >&
      data_int() const;

  // repeated .StepInfoKVString data_str = 2;
  int data_str_size() const;
  private:
  int _internal_data_str_size() const;
  public:
  void clear_data_str();
  ::StepInfoKVString* mutable_data_str(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVString >*
      mutable_data_str();
  private:
  const ::StepInfoKVString& _internal_data_str(int index) const;
  ::StepInfoKVString* _internal_add_data_str();
  public:
  const ::StepInfoKVString& data_str(int index) const;
  ::StepInfoKVString* add_data_str();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVString >&
      data_str() const;

  // repeated .StepInfoKVFloat data_float = 3;
  int data_float_size() const;
  private:
  int _internal_data_float_size() const;
  public:
  void clear_data_float();
  ::StepInfoKVFloat* mutable_data_float(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVFloat >*
      mutable_data_float();
  private:
  const ::StepInfoKVFloat& _internal_data_float(int index) const;
  ::StepInfoKVFloat* _internal_add_data_float();
  public:
  const ::StepInfoKVFloat& data_float(int index) const;
  ::StepInfoKVFloat* add_data_float();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVFloat >&
      data_float() const;

  // repeated .StepInfoKVBool data_bool = 4;
  int data_bool_size() const;
  private:
  int _internal_data_bool_size() const;
  public:
  void clear_data_bool();
  ::StepInfoKVBool* mutable_data_bool(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVBool >*
      mutable_data_bool();
  private:
  const ::StepInfoKVBool& _internal_data_bool(int index) const;
  ::StepInfoKVBool* _internal_add_data_bool();
  public:
  const ::StepInfoKVBool& data_bool(int index) const;
  ::StepInfoKVBool* add_data_bool();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVBool >&
      data_bool() const;

  // @@protoc_insertion_point(class_scope:StepInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVInt > data_int_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVString > data_str_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVFloat > data_float_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVBool > data_bool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Space final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Space) */ {
 public:
  inline Space() : Space(nullptr) {}
  ~Space() override;
  explicit PROTOBUF_CONSTEXPR Space(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Space(const Space& from);
  Space(Space&& from) noexcept
    : Space() {
    *this = ::std::move(from);
  }

  inline Space& operator=(const Space& from) {
    CopyFrom(from);
    return *this;
  }
  inline Space& operator=(Space&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Space& default_instance() {
    return *internal_default_instance();
  }
  static inline const Space* internal_default_instance() {
    return reinterpret_cast<const Space*>(
               &_Space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Space& a, Space& b) {
    a.Swap(&b);
  }
  inline void Swap(Space* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Space* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Space* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Space>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Space& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Space& from) {
    Space::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Space* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Space";
  }
  protected:
  explicit Space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 2,
    kLowFFieldNumber = 5,
    kHighFFieldNumber = 6,
    kLowIFieldNumber = 7,
    kHighIFieldNumber = 8,
    kTypeFieldNumber = 1,
    kDtypeFieldNumber = 3,
    kKeyFieldNumber = 4,
    kNFieldNumber = 9,
  };
  // repeated int32 shape = 2;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated float low_f = 5;
  int low_f_size() const;
  private:
  int _internal_low_f_size() const;
  public:
  void clear_low_f();
  private:
  float _internal_low_f(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_low_f() const;
  void _internal_add_low_f(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_low_f();
  public:
  float low_f(int index) const;
  void set_low_f(int index, float value);
  void add_low_f(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      low_f() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_low_f();

  // repeated float high_f = 6;
  int high_f_size() const;
  private:
  int _internal_high_f_size() const;
  public:
  void clear_high_f();
  private:
  float _internal_high_f(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_high_f() const;
  void _internal_add_high_f(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_high_f();
  public:
  float high_f(int index) const;
  void set_high_f(int index, float value);
  void add_high_f(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      high_f() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_high_f();

  // repeated int32 low_i = 7;
  int low_i_size() const;
  private:
  int _internal_low_i_size() const;
  public:
  void clear_low_i();
  private:
  int32_t _internal_low_i(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_low_i() const;
  void _internal_add_low_i(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_low_i();
  public:
  int32_t low_i(int index) const;
  void set_low_i(int index, int32_t value);
  void add_low_i(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      low_i() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_low_i();

  // repeated int32 high_i = 8;
  int high_i_size() const;
  private:
  int _internal_high_i_size() const;
  public:
  void clear_high_i();
  private:
  int32_t _internal_high_i(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_high_i() const;
  void _internal_add_high_i(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_high_i();
  public:
  int32_t high_i(int index) const;
  void set_high_i(int index, int32_t value);
  void add_high_i(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      high_i() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_high_i();

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string dtype = 3;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // string key = 4;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 n = 9;
  void clear_n();
  int32_t n() const;
  void set_n(int32_t value);
  private:
  int32_t _internal_n() const;
  void _internal_set_n(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Space)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > low_f_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > high_f_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > low_i_;
    mutable std::atomic<int> _low_i_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > high_i_;
    mutable std::atomic<int> _high_i_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Observation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Observation) */ {
 public:
  inline Observation() : Observation(nullptr) {}
  ~Observation() override;
  explicit PROTOBUF_CONSTEXPR Observation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Observation(const Observation& from);
  Observation(Observation&& from) noexcept
    : Observation() {
    *this = ::std::move(from);
  }

  inline Observation& operator=(const Observation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Observation& operator=(Observation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Observation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Observation* internal_default_instance() {
    return reinterpret_cast<const Observation*>(
               &_Observation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Observation& a, Observation& b) {
    a.Swap(&b);
  }
  inline void Swap(Observation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Observation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Observation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Observation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Observation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Observation& from) {
    Observation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Observation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Observation";
  }
  protected:
  explicit Observation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFFieldNumber = 1,
    kDataIFieldNumber = 2,
    kShapeFieldNumber = 3,
  };
  // repeated float data_f = 1;
  int data_f_size() const;
  private:
  int _internal_data_f_size() const;
  public:
  void clear_data_f();
  private:
  float _internal_data_f(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data_f() const;
  void _internal_add_data_f(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data_f();
  public:
  float data_f(int index) const;
  void set_data_f(int index, float value);
  void add_data_f(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data_f() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data_f();

  // repeated int32 data_i = 2;
  int data_i_size() const;
  private:
  int _internal_data_i_size() const;
  public:
  void clear_data_i();
  private:
  int32_t _internal_data_i(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data_i() const;
  void _internal_add_data_i(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data_i();
  public:
  int32_t data_i(int index) const;
  void set_data_i(int index, int32_t value);
  void add_data_i(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data_i() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data_i();

  // repeated int32 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:Observation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_f_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_i_;
    mutable std::atomic<int> _data_i_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFFieldNumber = 1,
    kDataIFieldNumber = 2,
    kShapeFieldNumber = 3,
  };
  // repeated int32 data_f = 1;
  int data_f_size() const;
  private:
  int _internal_data_f_size() const;
  public:
  void clear_data_f();
  private:
  int32_t _internal_data_f(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data_f() const;
  void _internal_add_data_f(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data_f();
  public:
  int32_t data_f(int index) const;
  void set_data_f(int index, int32_t value);
  void add_data_f(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data_f() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data_f();

  // repeated int32 data_i = 2;
  int data_i_size() const;
  private:
  int _internal_data_i_size() const;
  public:
  void clear_data_i();
  private:
  int32_t _internal_data_i(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_data_i() const;
  void _internal_add_data_i(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_data_i();
  public:
  int32_t data_i(int index) const;
  void set_data_i(int index, int32_t value);
  void add_data_i(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      data_i() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_data_i();

  // repeated int32 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_f_;
    mutable std::atomic<int> _data_f_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > data_i_;
    mutable std::atomic<int> _data_i_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class Transition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transition) */ {
 public:
  inline Transition() : Transition(nullptr) {}
  ~Transition() override;
  explicit PROTOBUF_CONSTEXPR Transition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transition(const Transition& from);
  Transition(Transition&& from) noexcept
    : Transition() {
    *this = ::std::move(from);
  }

  inline Transition& operator=(const Transition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transition& operator=(Transition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transition* internal_default_instance() {
    return reinterpret_cast<const Transition*>(
               &_Transition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Transition& a, Transition& b) {
    a.Swap(&b);
  }
  inline void Swap(Transition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transition& from) {
    Transition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transition";
  }
  protected:
  explicit Transition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextObservationFieldNumber = 1,
    kInfoFieldNumber = 4,
    kRewardFieldNumber = 2,
    kDoneFieldNumber = 3,
  };
  // .Observation next_observation = 1;
  bool has_next_observation() const;
  private:
  bool _internal_has_next_observation() const;
  public:
  void clear_next_observation();
  const ::Observation& next_observation() const;
  PROTOBUF_NODISCARD ::Observation* release_next_observation();
  ::Observation* mutable_next_observation();
  void set_allocated_next_observation(::Observation* next_observation);
  private:
  const ::Observation& _internal_next_observation() const;
  ::Observation* _internal_mutable_next_observation();
  public:
  void unsafe_arena_set_allocated_next_observation(
      ::Observation* next_observation);
  ::Observation* unsafe_arena_release_next_observation();

  // .StepInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::StepInfo& info() const;
  PROTOBUF_NODISCARD ::StepInfo* release_info();
  ::StepInfo* mutable_info();
  void set_allocated_info(::StepInfo* info);
  private:
  const ::StepInfo& _internal_info() const;
  ::StepInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::StepInfo* info);
  ::StepInfo* unsafe_arena_release_info();

  // float reward = 2;
  void clear_reward();
  float reward() const;
  void set_reward(float value);
  private:
  float _internal_reward() const;
  void _internal_set_reward(float value);
  public:

  // bool done = 3;
  void clear_done();
  bool done() const;
  void set_done(bool value);
  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Transition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Observation* next_observation_;
    ::StepInfo* info_;
    float reward_;
    bool done_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class RenderMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RenderMode) */ {
 public:
  inline RenderMode() : RenderMode(nullptr) {}
  ~RenderMode() override;
  explicit PROTOBUF_CONSTEXPR RenderMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenderMode(const RenderMode& from);
  RenderMode(RenderMode&& from) noexcept
    : RenderMode() {
    *this = ::std::move(from);
  }

  inline RenderMode& operator=(const RenderMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenderMode& operator=(RenderMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenderMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenderMode* internal_default_instance() {
    return reinterpret_cast<const RenderMode*>(
               &_RenderMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RenderMode& a, RenderMode& b) {
    a.Swap(&b);
  }
  inline void Swap(RenderMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenderMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenderMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenderMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenderMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenderMode& from) {
    RenderMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenderMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenderMode";
  }
  protected:
  explicit RenderMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:RenderMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class RenderOut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RenderOut) */ {
 public:
  inline RenderOut() : RenderOut(nullptr) {}
  ~RenderOut() override;
  explicit PROTOBUF_CONSTEXPR RenderOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenderOut(const RenderOut& from);
  RenderOut(RenderOut&& from) noexcept
    : RenderOut() {
    *this = ::std::move(from);
  }

  inline RenderOut& operator=(const RenderOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenderOut& operator=(RenderOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenderOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenderOut* internal_default_instance() {
    return reinterpret_cast<const RenderOut*>(
               &_RenderOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RenderOut& a, RenderOut& b) {
    a.Swap(&b);
  }
  inline void Swap(RenderOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenderOut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenderOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenderOut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenderOut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenderOut& from) {
    RenderOut::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenderOut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenderOut";
  }
  protected:
  explicit RenderOut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRgbFieldNumber = 1,
    kAnsiFieldNumber = 2,
  };
  // repeated int32 rgb = 1;
  int rgb_size() const;
  private:
  int _internal_rgb_size() const;
  public:
  void clear_rgb();
  private:
  int32_t _internal_rgb(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_rgb() const;
  void _internal_add_rgb(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_rgb();
  public:
  int32_t rgb(int index) const;
  void set_rgb(int index, int32_t value);
  void add_rgb(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      rgb() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_rgb();

  // string ansi = 2;
  void clear_ansi();
  const std::string& ansi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ansi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ansi();
  PROTOBUF_NODISCARD std::string* release_ansi();
  void set_allocated_ansi(std::string* ansi);
  private:
  const std::string& _internal_ansi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ansi(const std::string& value);
  std::string* _internal_mutable_ansi();
  public:

  // @@protoc_insertion_point(class_scope:RenderOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > rgb_;
    mutable std::atomic<int> _rgb_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ansi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// -------------------------------------------------------------------

class EnvSeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EnvSeed) */ {
 public:
  inline EnvSeed() : EnvSeed(nullptr) {}
  ~EnvSeed() override;
  explicit PROTOBUF_CONSTEXPR EnvSeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvSeed(const EnvSeed& from);
  EnvSeed(EnvSeed&& from) noexcept
    : EnvSeed() {
    *this = ::std::move(from);
  }

  inline EnvSeed& operator=(const EnvSeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvSeed& operator=(EnvSeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvSeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvSeed* internal_default_instance() {
    return reinterpret_cast<const EnvSeed*>(
               &_EnvSeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EnvSeed& a, EnvSeed& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvSeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvSeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvSeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvSeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvSeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnvSeed& from) {
    EnvSeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvSeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EnvSeed";
  }
  protected:
  explicit EnvSeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // int32 data = 1;
  void clear_data();
  int32_t data() const;
  void set_data(int32_t value);
  private:
  int32_t _internal_data() const;
  void _internal_set_data(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EnvSeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerInfo

// string ip = 1;
inline void ServerInfo::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& ServerInfo::ip() const {
  // @@protoc_insertion_point(field_get:ServerInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.ip)
}
inline std::string* ServerInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:ServerInfo.ip)
  return _s;
}
inline const std::string& ServerInfo::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void ServerInfo::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_ip() {
  // @@protoc_insertion_point(field_release:ServerInfo.ip)
  return _impl_.ip_.Release();
}
inline void ServerInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.ip)
}

// int32 port = 2;
inline void ServerInfo::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t ServerInfo::_internal_port() const {
  return _impl_.port_;
}
inline int32_t ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:ServerInfo.port)
  return _internal_port();
}
inline void ServerInfo::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void ServerInfo::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ServerInfo.port)
}

// -------------------------------------------------------------------

// MetaData

// string EnvVersion = 1;
inline void MetaData::clear_envversion() {
  _impl_.envversion_.ClearToEmpty();
}
inline const std::string& MetaData::envversion() const {
  // @@protoc_insertion_point(field_get:MetaData.EnvVersion)
  return _internal_envversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaData::set_envversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.envversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MetaData.EnvVersion)
}
inline std::string* MetaData::mutable_envversion() {
  std::string* _s = _internal_mutable_envversion();
  // @@protoc_insertion_point(field_mutable:MetaData.EnvVersion)
  return _s;
}
inline const std::string& MetaData::_internal_envversion() const {
  return _impl_.envversion_.Get();
}
inline void MetaData::_internal_set_envversion(const std::string& value) {
  
  _impl_.envversion_.Set(value, GetArenaForAllocation());
}
inline std::string* MetaData::_internal_mutable_envversion() {
  
  return _impl_.envversion_.Mutable(GetArenaForAllocation());
}
inline std::string* MetaData::release_envversion() {
  // @@protoc_insertion_point(field_release:MetaData.EnvVersion)
  return _impl_.envversion_.Release();
}
inline void MetaData::set_allocated_envversion(std::string* envversion) {
  if (envversion != nullptr) {
    
  } else {
    
  }
  _impl_.envversion_.SetAllocated(envversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.envversion_.IsDefault()) {
    _impl_.envversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MetaData.EnvVersion)
}

// -------------------------------------------------------------------

// Name

// string data = 1;
inline void Name::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Name::data() const {
  // @@protoc_insertion_point(field_get:Name.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Name.data)
}
inline std::string* Name::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Name.data)
  return _s;
}
inline const std::string& Name::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Name::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_data() {
  // @@protoc_insertion_point(field_release:Name.data)
  return _impl_.data_.Release();
}
inline void Name::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Name.data)
}

// repeated string wrapper = 2;
inline int Name::_internal_wrapper_size() const {
  return _impl_.wrapper_.size();
}
inline int Name::wrapper_size() const {
  return _internal_wrapper_size();
}
inline void Name::clear_wrapper() {
  _impl_.wrapper_.Clear();
}
inline std::string* Name::add_wrapper() {
  std::string* _s = _internal_add_wrapper();
  // @@protoc_insertion_point(field_add_mutable:Name.wrapper)
  return _s;
}
inline const std::string& Name::_internal_wrapper(int index) const {
  return _impl_.wrapper_.Get(index);
}
inline const std::string& Name::wrapper(int index) const {
  // @@protoc_insertion_point(field_get:Name.wrapper)
  return _internal_wrapper(index);
}
inline std::string* Name::mutable_wrapper(int index) {
  // @@protoc_insertion_point(field_mutable:Name.wrapper)
  return _impl_.wrapper_.Mutable(index);
}
inline void Name::set_wrapper(int index, const std::string& value) {
  _impl_.wrapper_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Name.wrapper)
}
inline void Name::set_wrapper(int index, std::string&& value) {
  _impl_.wrapper_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Name.wrapper)
}
inline void Name::set_wrapper(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wrapper_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Name.wrapper)
}
inline void Name::set_wrapper(int index, const char* value, size_t size) {
  _impl_.wrapper_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Name.wrapper)
}
inline std::string* Name::_internal_add_wrapper() {
  return _impl_.wrapper_.Add();
}
inline void Name::add_wrapper(const std::string& value) {
  _impl_.wrapper_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Name.wrapper)
}
inline void Name::add_wrapper(std::string&& value) {
  _impl_.wrapper_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Name.wrapper)
}
inline void Name::add_wrapper(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wrapper_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Name.wrapper)
}
inline void Name::add_wrapper(const char* value, size_t size) {
  _impl_.wrapper_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Name.wrapper)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Name::wrapper() const {
  // @@protoc_insertion_point(field_list:Name.wrapper)
  return _impl_.wrapper_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Name::mutable_wrapper() {
  // @@protoc_insertion_point(field_mutable_list:Name.wrapper)
  return &_impl_.wrapper_;
}

// string render_mode = 3;
inline void Name::clear_render_mode() {
  _impl_.render_mode_.ClearToEmpty();
}
inline const std::string& Name::render_mode() const {
  // @@protoc_insertion_point(field_get:Name.render_mode)
  return _internal_render_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Name::set_render_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.render_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Name.render_mode)
}
inline std::string* Name::mutable_render_mode() {
  std::string* _s = _internal_mutable_render_mode();
  // @@protoc_insertion_point(field_mutable:Name.render_mode)
  return _s;
}
inline const std::string& Name::_internal_render_mode() const {
  return _impl_.render_mode_.Get();
}
inline void Name::_internal_set_render_mode(const std::string& value) {
  
  _impl_.render_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* Name::_internal_mutable_render_mode() {
  
  return _impl_.render_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* Name::release_render_mode() {
  // @@protoc_insertion_point(field_release:Name.render_mode)
  return _impl_.render_mode_.Release();
}
inline void Name::set_allocated_render_mode(std::string* render_mode) {
  if (render_mode != nullptr) {
    
  } else {
    
  }
  _impl_.render_mode_.SetAllocated(render_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.render_mode_.IsDefault()) {
    _impl_.render_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Name.render_mode)
}

// -------------------------------------------------------------------

// Info

// repeated .Space observation_space = 1;
inline int Info::_internal_observation_space_size() const {
  return _impl_.observation_space_.size();
}
inline int Info::observation_space_size() const {
  return _internal_observation_space_size();
}
inline void Info::clear_observation_space() {
  _impl_.observation_space_.Clear();
}
inline ::Space* Info::mutable_observation_space(int index) {
  // @@protoc_insertion_point(field_mutable:Info.observation_space)
  return _impl_.observation_space_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >*
Info::mutable_observation_space() {
  // @@protoc_insertion_point(field_mutable_list:Info.observation_space)
  return &_impl_.observation_space_;
}
inline const ::Space& Info::_internal_observation_space(int index) const {
  return _impl_.observation_space_.Get(index);
}
inline const ::Space& Info::observation_space(int index) const {
  // @@protoc_insertion_point(field_get:Info.observation_space)
  return _internal_observation_space(index);
}
inline ::Space* Info::_internal_add_observation_space() {
  return _impl_.observation_space_.Add();
}
inline ::Space* Info::add_observation_space() {
  ::Space* _add = _internal_add_observation_space();
  // @@protoc_insertion_point(field_add:Info.observation_space)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >&
Info::observation_space() const {
  // @@protoc_insertion_point(field_list:Info.observation_space)
  return _impl_.observation_space_;
}

// repeated .Space action_space = 2;
inline int Info::_internal_action_space_size() const {
  return _impl_.action_space_.size();
}
inline int Info::action_space_size() const {
  return _internal_action_space_size();
}
inline void Info::clear_action_space() {
  _impl_.action_space_.Clear();
}
inline ::Space* Info::mutable_action_space(int index) {
  // @@protoc_insertion_point(field_mutable:Info.action_space)
  return _impl_.action_space_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >*
Info::mutable_action_space() {
  // @@protoc_insertion_point(field_mutable_list:Info.action_space)
  return &_impl_.action_space_;
}
inline const ::Space& Info::_internal_action_space(int index) const {
  return _impl_.action_space_.Get(index);
}
inline const ::Space& Info::action_space(int index) const {
  // @@protoc_insertion_point(field_get:Info.action_space)
  return _internal_action_space(index);
}
inline ::Space* Info::_internal_add_action_space() {
  return _impl_.action_space_.Add();
}
inline ::Space* Info::add_action_space() {
  ::Space* _add = _internal_add_action_space();
  // @@protoc_insertion_point(field_add:Info.action_space)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Space >&
Info::action_space() const {
  // @@protoc_insertion_point(field_list:Info.action_space)
  return _impl_.action_space_;
}

// int32 max_episode_steps = 3;
inline void Info::clear_max_episode_steps() {
  _impl_.max_episode_steps_ = 0;
}
inline int32_t Info::_internal_max_episode_steps() const {
  return _impl_.max_episode_steps_;
}
inline int32_t Info::max_episode_steps() const {
  // @@protoc_insertion_point(field_get:Info.max_episode_steps)
  return _internal_max_episode_steps();
}
inline void Info::_internal_set_max_episode_steps(int32_t value) {
  
  _impl_.max_episode_steps_ = value;
}
inline void Info::set_max_episode_steps(int32_t value) {
  _internal_set_max_episode_steps(value);
  // @@protoc_insertion_point(field_set:Info.max_episode_steps)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StepInfoKV

// map<string, string> s_map = 1;
inline int StepInfoKV::_internal_s_map_size() const {
  return _impl_.s_map_.size();
}
inline int StepInfoKV::s_map_size() const {
  return _internal_s_map_size();
}
inline void StepInfoKV::clear_s_map() {
  _impl_.s_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StepInfoKV::_internal_s_map() const {
  return _impl_.s_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StepInfoKV::s_map() const {
  // @@protoc_insertion_point(field_map:StepInfoKV.s_map)
  return _internal_s_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StepInfoKV::_internal_mutable_s_map() {
  return _impl_.s_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StepInfoKV::mutable_s_map() {
  // @@protoc_insertion_point(field_mutable_map:StepInfoKV.s_map)
  return _internal_mutable_s_map();
}

// map<string, int32> i_map = 2;
inline int StepInfoKV::_internal_i_map_size() const {
  return _impl_.i_map_.size();
}
inline int StepInfoKV::i_map_size() const {
  return _internal_i_map_size();
}
inline void StepInfoKV::clear_i_map() {
  _impl_.i_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
StepInfoKV::_internal_i_map() const {
  return _impl_.i_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
StepInfoKV::i_map() const {
  // @@protoc_insertion_point(field_map:StepInfoKV.i_map)
  return _internal_i_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
StepInfoKV::_internal_mutable_i_map() {
  return _impl_.i_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
StepInfoKV::mutable_i_map() {
  // @@protoc_insertion_point(field_mutable_map:StepInfoKV.i_map)
  return _internal_mutable_i_map();
}

// map<string, float> f_map = 3;
inline int StepInfoKV::_internal_f_map_size() const {
  return _impl_.f_map_.size();
}
inline int StepInfoKV::f_map_size() const {
  return _internal_f_map_size();
}
inline void StepInfoKV::clear_f_map() {
  _impl_.f_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
StepInfoKV::_internal_f_map() const {
  return _impl_.f_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
StepInfoKV::f_map() const {
  // @@protoc_insertion_point(field_map:StepInfoKV.f_map)
  return _internal_f_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
StepInfoKV::_internal_mutable_f_map() {
  return _impl_.f_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
StepInfoKV::mutable_f_map() {
  // @@protoc_insertion_point(field_mutable_map:StepInfoKV.f_map)
  return _internal_mutable_f_map();
}

// map<string, bool> b_map = 4;
inline int StepInfoKV::_internal_b_map_size() const {
  return _impl_.b_map_.size();
}
inline int StepInfoKV::b_map_size() const {
  return _internal_b_map_size();
}
inline void StepInfoKV::clear_b_map() {
  _impl_.b_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
StepInfoKV::_internal_b_map() const {
  return _impl_.b_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
StepInfoKV::b_map() const {
  // @@protoc_insertion_point(field_map:StepInfoKV.b_map)
  return _internal_b_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
StepInfoKV::_internal_mutable_b_map() {
  return _impl_.b_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
StepInfoKV::mutable_b_map() {
  // @@protoc_insertion_point(field_mutable_map:StepInfoKV.b_map)
  return _internal_mutable_b_map();
}

// -------------------------------------------------------------------

// StepInfoKVInt

// string key = 1;
inline void StepInfoKVInt::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StepInfoKVInt::key() const {
  // @@protoc_insertion_point(field_get:StepInfoKVInt.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepInfoKVInt::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StepInfoKVInt.key)
}
inline std::string* StepInfoKVInt::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StepInfoKVInt.key)
  return _s;
}
inline const std::string& StepInfoKVInt::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StepInfoKVInt::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StepInfoKVInt::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StepInfoKVInt::release_key() {
  // @@protoc_insertion_point(field_release:StepInfoKVInt.key)
  return _impl_.key_.Release();
}
inline void StepInfoKVInt::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StepInfoKVInt.key)
}

// int32 value = 2;
inline void StepInfoKVInt::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t StepInfoKVInt::_internal_value() const {
  return _impl_.value_;
}
inline int32_t StepInfoKVInt::value() const {
  // @@protoc_insertion_point(field_get:StepInfoKVInt.value)
  return _internal_value();
}
inline void StepInfoKVInt::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void StepInfoKVInt::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:StepInfoKVInt.value)
}

// -------------------------------------------------------------------

// StepInfoKVString

// string key = 1;
inline void StepInfoKVString::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StepInfoKVString::key() const {
  // @@protoc_insertion_point(field_get:StepInfoKVString.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepInfoKVString::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StepInfoKVString.key)
}
inline std::string* StepInfoKVString::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StepInfoKVString.key)
  return _s;
}
inline const std::string& StepInfoKVString::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StepInfoKVString::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StepInfoKVString::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StepInfoKVString::release_key() {
  // @@protoc_insertion_point(field_release:StepInfoKVString.key)
  return _impl_.key_.Release();
}
inline void StepInfoKVString::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StepInfoKVString.key)
}

// string value = 2;
inline void StepInfoKVString::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StepInfoKVString::value() const {
  // @@protoc_insertion_point(field_get:StepInfoKVString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepInfoKVString::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StepInfoKVString.value)
}
inline std::string* StepInfoKVString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:StepInfoKVString.value)
  return _s;
}
inline const std::string& StepInfoKVString::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StepInfoKVString::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StepInfoKVString::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StepInfoKVString::release_value() {
  // @@protoc_insertion_point(field_release:StepInfoKVString.value)
  return _impl_.value_.Release();
}
inline void StepInfoKVString::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StepInfoKVString.value)
}

// -------------------------------------------------------------------

// StepInfoKVFloat

// string key = 1;
inline void StepInfoKVFloat::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StepInfoKVFloat::key() const {
  // @@protoc_insertion_point(field_get:StepInfoKVFloat.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepInfoKVFloat::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StepInfoKVFloat.key)
}
inline std::string* StepInfoKVFloat::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StepInfoKVFloat.key)
  return _s;
}
inline const std::string& StepInfoKVFloat::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StepInfoKVFloat::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StepInfoKVFloat::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StepInfoKVFloat::release_key() {
  // @@protoc_insertion_point(field_release:StepInfoKVFloat.key)
  return _impl_.key_.Release();
}
inline void StepInfoKVFloat::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StepInfoKVFloat.key)
}

// float value = 2;
inline void StepInfoKVFloat::clear_value() {
  _impl_.value_ = 0;
}
inline float StepInfoKVFloat::_internal_value() const {
  return _impl_.value_;
}
inline float StepInfoKVFloat::value() const {
  // @@protoc_insertion_point(field_get:StepInfoKVFloat.value)
  return _internal_value();
}
inline void StepInfoKVFloat::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void StepInfoKVFloat::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:StepInfoKVFloat.value)
}

// -------------------------------------------------------------------

// StepInfoKVBool

// string key = 1;
inline void StepInfoKVBool::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StepInfoKVBool::key() const {
  // @@protoc_insertion_point(field_get:StepInfoKVBool.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepInfoKVBool::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StepInfoKVBool.key)
}
inline std::string* StepInfoKVBool::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StepInfoKVBool.key)
  return _s;
}
inline const std::string& StepInfoKVBool::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StepInfoKVBool::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StepInfoKVBool::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StepInfoKVBool::release_key() {
  // @@protoc_insertion_point(field_release:StepInfoKVBool.key)
  return _impl_.key_.Release();
}
inline void StepInfoKVBool::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StepInfoKVBool.key)
}

// bool value = 2;
inline void StepInfoKVBool::clear_value() {
  _impl_.value_ = false;
}
inline bool StepInfoKVBool::_internal_value() const {
  return _impl_.value_;
}
inline bool StepInfoKVBool::value() const {
  // @@protoc_insertion_point(field_get:StepInfoKVBool.value)
  return _internal_value();
}
inline void StepInfoKVBool::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void StepInfoKVBool::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:StepInfoKVBool.value)
}

// -------------------------------------------------------------------

// StepInfo

// repeated .StepInfoKVInt data_int = 1;
inline int StepInfo::_internal_data_int_size() const {
  return _impl_.data_int_.size();
}
inline int StepInfo::data_int_size() const {
  return _internal_data_int_size();
}
inline void StepInfo::clear_data_int() {
  _impl_.data_int_.Clear();
}
inline ::StepInfoKVInt* StepInfo::mutable_data_int(int index) {
  // @@protoc_insertion_point(field_mutable:StepInfo.data_int)
  return _impl_.data_int_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVInt >*
StepInfo::mutable_data_int() {
  // @@protoc_insertion_point(field_mutable_list:StepInfo.data_int)
  return &_impl_.data_int_;
}
inline const ::StepInfoKVInt& StepInfo::_internal_data_int(int index) const {
  return _impl_.data_int_.Get(index);
}
inline const ::StepInfoKVInt& StepInfo::data_int(int index) const {
  // @@protoc_insertion_point(field_get:StepInfo.data_int)
  return _internal_data_int(index);
}
inline ::StepInfoKVInt* StepInfo::_internal_add_data_int() {
  return _impl_.data_int_.Add();
}
inline ::StepInfoKVInt* StepInfo::add_data_int() {
  ::StepInfoKVInt* _add = _internal_add_data_int();
  // @@protoc_insertion_point(field_add:StepInfo.data_int)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVInt >&
StepInfo::data_int() const {
  // @@protoc_insertion_point(field_list:StepInfo.data_int)
  return _impl_.data_int_;
}

// repeated .StepInfoKVString data_str = 2;
inline int StepInfo::_internal_data_str_size() const {
  return _impl_.data_str_.size();
}
inline int StepInfo::data_str_size() const {
  return _internal_data_str_size();
}
inline void StepInfo::clear_data_str() {
  _impl_.data_str_.Clear();
}
inline ::StepInfoKVString* StepInfo::mutable_data_str(int index) {
  // @@protoc_insertion_point(field_mutable:StepInfo.data_str)
  return _impl_.data_str_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVString >*
StepInfo::mutable_data_str() {
  // @@protoc_insertion_point(field_mutable_list:StepInfo.data_str)
  return &_impl_.data_str_;
}
inline const ::StepInfoKVString& StepInfo::_internal_data_str(int index) const {
  return _impl_.data_str_.Get(index);
}
inline const ::StepInfoKVString& StepInfo::data_str(int index) const {
  // @@protoc_insertion_point(field_get:StepInfo.data_str)
  return _internal_data_str(index);
}
inline ::StepInfoKVString* StepInfo::_internal_add_data_str() {
  return _impl_.data_str_.Add();
}
inline ::StepInfoKVString* StepInfo::add_data_str() {
  ::StepInfoKVString* _add = _internal_add_data_str();
  // @@protoc_insertion_point(field_add:StepInfo.data_str)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVString >&
StepInfo::data_str() const {
  // @@protoc_insertion_point(field_list:StepInfo.data_str)
  return _impl_.data_str_;
}

// repeated .StepInfoKVFloat data_float = 3;
inline int StepInfo::_internal_data_float_size() const {
  return _impl_.data_float_.size();
}
inline int StepInfo::data_float_size() const {
  return _internal_data_float_size();
}
inline void StepInfo::clear_data_float() {
  _impl_.data_float_.Clear();
}
inline ::StepInfoKVFloat* StepInfo::mutable_data_float(int index) {
  // @@protoc_insertion_point(field_mutable:StepInfo.data_float)
  return _impl_.data_float_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVFloat >*
StepInfo::mutable_data_float() {
  // @@protoc_insertion_point(field_mutable_list:StepInfo.data_float)
  return &_impl_.data_float_;
}
inline const ::StepInfoKVFloat& StepInfo::_internal_data_float(int index) const {
  return _impl_.data_float_.Get(index);
}
inline const ::StepInfoKVFloat& StepInfo::data_float(int index) const {
  // @@protoc_insertion_point(field_get:StepInfo.data_float)
  return _internal_data_float(index);
}
inline ::StepInfoKVFloat* StepInfo::_internal_add_data_float() {
  return _impl_.data_float_.Add();
}
inline ::StepInfoKVFloat* StepInfo::add_data_float() {
  ::StepInfoKVFloat* _add = _internal_add_data_float();
  // @@protoc_insertion_point(field_add:StepInfo.data_float)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVFloat >&
StepInfo::data_float() const {
  // @@protoc_insertion_point(field_list:StepInfo.data_float)
  return _impl_.data_float_;
}

// repeated .StepInfoKVBool data_bool = 4;
inline int StepInfo::_internal_data_bool_size() const {
  return _impl_.data_bool_.size();
}
inline int StepInfo::data_bool_size() const {
  return _internal_data_bool_size();
}
inline void StepInfo::clear_data_bool() {
  _impl_.data_bool_.Clear();
}
inline ::StepInfoKVBool* StepInfo::mutable_data_bool(int index) {
  // @@protoc_insertion_point(field_mutable:StepInfo.data_bool)
  return _impl_.data_bool_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVBool >*
StepInfo::mutable_data_bool() {
  // @@protoc_insertion_point(field_mutable_list:StepInfo.data_bool)
  return &_impl_.data_bool_;
}
inline const ::StepInfoKVBool& StepInfo::_internal_data_bool(int index) const {
  return _impl_.data_bool_.Get(index);
}
inline const ::StepInfoKVBool& StepInfo::data_bool(int index) const {
  // @@protoc_insertion_point(field_get:StepInfo.data_bool)
  return _internal_data_bool(index);
}
inline ::StepInfoKVBool* StepInfo::_internal_add_data_bool() {
  return _impl_.data_bool_.Add();
}
inline ::StepInfoKVBool* StepInfo::add_data_bool() {
  ::StepInfoKVBool* _add = _internal_add_data_bool();
  // @@protoc_insertion_point(field_add:StepInfo.data_bool)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StepInfoKVBool >&
StepInfo::data_bool() const {
  // @@protoc_insertion_point(field_list:StepInfo.data_bool)
  return _impl_.data_bool_;
}

// -------------------------------------------------------------------

// Space

// string type = 1;
inline void Space::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Space::type() const {
  // @@protoc_insertion_point(field_get:Space.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Space::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Space.type)
}
inline std::string* Space::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:Space.type)
  return _s;
}
inline const std::string& Space::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Space::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Space::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Space::release_type() {
  // @@protoc_insertion_point(field_release:Space.type)
  return _impl_.type_.Release();
}
inline void Space::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Space.type)
}

// repeated int32 shape = 2;
inline int Space::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Space::shape_size() const {
  return _internal_shape_size();
}
inline void Space::clear_shape() {
  _impl_.shape_.Clear();
}
inline int32_t Space::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int32_t Space::shape(int index) const {
  // @@protoc_insertion_point(field_get:Space.shape)
  return _internal_shape(index);
}
inline void Space::set_shape(int index, int32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.shape)
}
inline void Space::_internal_add_shape(int32_t value) {
  _impl_.shape_.Add(value);
}
inline void Space::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Space.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::shape() const {
  // @@protoc_insertion_point(field_list:Space.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Space.shape)
  return _internal_mutable_shape();
}

// string dtype = 3;
inline void Space::clear_dtype() {
  _impl_.dtype_.ClearToEmpty();
}
inline const std::string& Space::dtype() const {
  // @@protoc_insertion_point(field_get:Space.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Space::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Space.dtype)
}
inline std::string* Space::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:Space.dtype)
  return _s;
}
inline const std::string& Space::_internal_dtype() const {
  return _impl_.dtype_.Get();
}
inline void Space::_internal_set_dtype(const std::string& value) {
  
  _impl_.dtype_.Set(value, GetArenaForAllocation());
}
inline std::string* Space::_internal_mutable_dtype() {
  
  return _impl_.dtype_.Mutable(GetArenaForAllocation());
}
inline std::string* Space::release_dtype() {
  // @@protoc_insertion_point(field_release:Space.dtype)
  return _impl_.dtype_.Release();
}
inline void Space::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  _impl_.dtype_.SetAllocated(dtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Space.dtype)
}

// string key = 4;
inline void Space::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Space::key() const {
  // @@protoc_insertion_point(field_get:Space.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Space::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Space.key)
}
inline std::string* Space::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:Space.key)
  return _s;
}
inline const std::string& Space::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Space::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Space::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Space::release_key() {
  // @@protoc_insertion_point(field_release:Space.key)
  return _impl_.key_.Release();
}
inline void Space::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Space.key)
}

// repeated float low_f = 5;
inline int Space::_internal_low_f_size() const {
  return _impl_.low_f_.size();
}
inline int Space::low_f_size() const {
  return _internal_low_f_size();
}
inline void Space::clear_low_f() {
  _impl_.low_f_.Clear();
}
inline float Space::_internal_low_f(int index) const {
  return _impl_.low_f_.Get(index);
}
inline float Space::low_f(int index) const {
  // @@protoc_insertion_point(field_get:Space.low_f)
  return _internal_low_f(index);
}
inline void Space::set_low_f(int index, float value) {
  _impl_.low_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.low_f)
}
inline void Space::_internal_add_low_f(float value) {
  _impl_.low_f_.Add(value);
}
inline void Space::add_low_f(float value) {
  _internal_add_low_f(value);
  // @@protoc_insertion_point(field_add:Space.low_f)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::_internal_low_f() const {
  return _impl_.low_f_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::low_f() const {
  // @@protoc_insertion_point(field_list:Space.low_f)
  return _internal_low_f();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::_internal_mutable_low_f() {
  return &_impl_.low_f_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::mutable_low_f() {
  // @@protoc_insertion_point(field_mutable_list:Space.low_f)
  return _internal_mutable_low_f();
}

// repeated float high_f = 6;
inline int Space::_internal_high_f_size() const {
  return _impl_.high_f_.size();
}
inline int Space::high_f_size() const {
  return _internal_high_f_size();
}
inline void Space::clear_high_f() {
  _impl_.high_f_.Clear();
}
inline float Space::_internal_high_f(int index) const {
  return _impl_.high_f_.Get(index);
}
inline float Space::high_f(int index) const {
  // @@protoc_insertion_point(field_get:Space.high_f)
  return _internal_high_f(index);
}
inline void Space::set_high_f(int index, float value) {
  _impl_.high_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.high_f)
}
inline void Space::_internal_add_high_f(float value) {
  _impl_.high_f_.Add(value);
}
inline void Space::add_high_f(float value) {
  _internal_add_high_f(value);
  // @@protoc_insertion_point(field_add:Space.high_f)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::_internal_high_f() const {
  return _impl_.high_f_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::high_f() const {
  // @@protoc_insertion_point(field_list:Space.high_f)
  return _internal_high_f();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::_internal_mutable_high_f() {
  return &_impl_.high_f_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::mutable_high_f() {
  // @@protoc_insertion_point(field_mutable_list:Space.high_f)
  return _internal_mutable_high_f();
}

// repeated int32 low_i = 7;
inline int Space::_internal_low_i_size() const {
  return _impl_.low_i_.size();
}
inline int Space::low_i_size() const {
  return _internal_low_i_size();
}
inline void Space::clear_low_i() {
  _impl_.low_i_.Clear();
}
inline int32_t Space::_internal_low_i(int index) const {
  return _impl_.low_i_.Get(index);
}
inline int32_t Space::low_i(int index) const {
  // @@protoc_insertion_point(field_get:Space.low_i)
  return _internal_low_i(index);
}
inline void Space::set_low_i(int index, int32_t value) {
  _impl_.low_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.low_i)
}
inline void Space::_internal_add_low_i(int32_t value) {
  _impl_.low_i_.Add(value);
}
inline void Space::add_low_i(int32_t value) {
  _internal_add_low_i(value);
  // @@protoc_insertion_point(field_add:Space.low_i)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::_internal_low_i() const {
  return _impl_.low_i_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::low_i() const {
  // @@protoc_insertion_point(field_list:Space.low_i)
  return _internal_low_i();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::_internal_mutable_low_i() {
  return &_impl_.low_i_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::mutable_low_i() {
  // @@protoc_insertion_point(field_mutable_list:Space.low_i)
  return _internal_mutable_low_i();
}

// repeated int32 high_i = 8;
inline int Space::_internal_high_i_size() const {
  return _impl_.high_i_.size();
}
inline int Space::high_i_size() const {
  return _internal_high_i_size();
}
inline void Space::clear_high_i() {
  _impl_.high_i_.Clear();
}
inline int32_t Space::_internal_high_i(int index) const {
  return _impl_.high_i_.Get(index);
}
inline int32_t Space::high_i(int index) const {
  // @@protoc_insertion_point(field_get:Space.high_i)
  return _internal_high_i(index);
}
inline void Space::set_high_i(int index, int32_t value) {
  _impl_.high_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.high_i)
}
inline void Space::_internal_add_high_i(int32_t value) {
  _impl_.high_i_.Add(value);
}
inline void Space::add_high_i(int32_t value) {
  _internal_add_high_i(value);
  // @@protoc_insertion_point(field_add:Space.high_i)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::_internal_high_i() const {
  return _impl_.high_i_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::high_i() const {
  // @@protoc_insertion_point(field_list:Space.high_i)
  return _internal_high_i();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::_internal_mutable_high_i() {
  return &_impl_.high_i_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::mutable_high_i() {
  // @@protoc_insertion_point(field_mutable_list:Space.high_i)
  return _internal_mutable_high_i();
}

// int32 n = 9;
inline void Space::clear_n() {
  _impl_.n_ = 0;
}
inline int32_t Space::_internal_n() const {
  return _impl_.n_;
}
inline int32_t Space::n() const {
  // @@protoc_insertion_point(field_get:Space.n)
  return _internal_n();
}
inline void Space::_internal_set_n(int32_t value) {
  
  _impl_.n_ = value;
}
inline void Space::set_n(int32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:Space.n)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Observation

// repeated float data_f = 1;
inline int Observation::_internal_data_f_size() const {
  return _impl_.data_f_.size();
}
inline int Observation::data_f_size() const {
  return _internal_data_f_size();
}
inline void Observation::clear_data_f() {
  _impl_.data_f_.Clear();
}
inline float Observation::_internal_data_f(int index) const {
  return _impl_.data_f_.Get(index);
}
inline float Observation::data_f(int index) const {
  // @@protoc_insertion_point(field_get:Observation.data_f)
  return _internal_data_f(index);
}
inline void Observation::set_data_f(int index, float value) {
  _impl_.data_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:Observation.data_f)
}
inline void Observation::_internal_add_data_f(float value) {
  _impl_.data_f_.Add(value);
}
inline void Observation::add_data_f(float value) {
  _internal_add_data_f(value);
  // @@protoc_insertion_point(field_add:Observation.data_f)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Observation::_internal_data_f() const {
  return _impl_.data_f_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Observation::data_f() const {
  // @@protoc_insertion_point(field_list:Observation.data_f)
  return _internal_data_f();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Observation::_internal_mutable_data_f() {
  return &_impl_.data_f_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Observation::mutable_data_f() {
  // @@protoc_insertion_point(field_mutable_list:Observation.data_f)
  return _internal_mutable_data_f();
}

// repeated int32 data_i = 2;
inline int Observation::_internal_data_i_size() const {
  return _impl_.data_i_.size();
}
inline int Observation::data_i_size() const {
  return _internal_data_i_size();
}
inline void Observation::clear_data_i() {
  _impl_.data_i_.Clear();
}
inline int32_t Observation::_internal_data_i(int index) const {
  return _impl_.data_i_.Get(index);
}
inline int32_t Observation::data_i(int index) const {
  // @@protoc_insertion_point(field_get:Observation.data_i)
  return _internal_data_i(index);
}
inline void Observation::set_data_i(int index, int32_t value) {
  _impl_.data_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:Observation.data_i)
}
inline void Observation::_internal_add_data_i(int32_t value) {
  _impl_.data_i_.Add(value);
}
inline void Observation::add_data_i(int32_t value) {
  _internal_add_data_i(value);
  // @@protoc_insertion_point(field_add:Observation.data_i)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Observation::_internal_data_i() const {
  return _impl_.data_i_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Observation::data_i() const {
  // @@protoc_insertion_point(field_list:Observation.data_i)
  return _internal_data_i();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Observation::_internal_mutable_data_i() {
  return &_impl_.data_i_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Observation::mutable_data_i() {
  // @@protoc_insertion_point(field_mutable_list:Observation.data_i)
  return _internal_mutable_data_i();
}

// repeated int32 shape = 3;
inline int Observation::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Observation::shape_size() const {
  return _internal_shape_size();
}
inline void Observation::clear_shape() {
  _impl_.shape_.Clear();
}
inline int32_t Observation::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int32_t Observation::shape(int index) const {
  // @@protoc_insertion_point(field_get:Observation.shape)
  return _internal_shape(index);
}
inline void Observation::set_shape(int index, int32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Observation.shape)
}
inline void Observation::_internal_add_shape(int32_t value) {
  _impl_.shape_.Add(value);
}
inline void Observation::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Observation.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Observation::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Observation::shape() const {
  // @@protoc_insertion_point(field_list:Observation.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Observation::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Observation::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Observation.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// Action

// repeated int32 data_f = 1;
inline int Action::_internal_data_f_size() const {
  return _impl_.data_f_.size();
}
inline int Action::data_f_size() const {
  return _internal_data_f_size();
}
inline void Action::clear_data_f() {
  _impl_.data_f_.Clear();
}
inline int32_t Action::_internal_data_f(int index) const {
  return _impl_.data_f_.Get(index);
}
inline int32_t Action::data_f(int index) const {
  // @@protoc_insertion_point(field_get:Action.data_f)
  return _internal_data_f(index);
}
inline void Action::set_data_f(int index, int32_t value) {
  _impl_.data_f_.Set(index, value);
  // @@protoc_insertion_point(field_set:Action.data_f)
}
inline void Action::_internal_add_data_f(int32_t value) {
  _impl_.data_f_.Add(value);
}
inline void Action::add_data_f(int32_t value) {
  _internal_add_data_f(value);
  // @@protoc_insertion_point(field_add:Action.data_f)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::_internal_data_f() const {
  return _impl_.data_f_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::data_f() const {
  // @@protoc_insertion_point(field_list:Action.data_f)
  return _internal_data_f();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::_internal_mutable_data_f() {
  return &_impl_.data_f_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::mutable_data_f() {
  // @@protoc_insertion_point(field_mutable_list:Action.data_f)
  return _internal_mutable_data_f();
}

// repeated int32 data_i = 2;
inline int Action::_internal_data_i_size() const {
  return _impl_.data_i_.size();
}
inline int Action::data_i_size() const {
  return _internal_data_i_size();
}
inline void Action::clear_data_i() {
  _impl_.data_i_.Clear();
}
inline int32_t Action::_internal_data_i(int index) const {
  return _impl_.data_i_.Get(index);
}
inline int32_t Action::data_i(int index) const {
  // @@protoc_insertion_point(field_get:Action.data_i)
  return _internal_data_i(index);
}
inline void Action::set_data_i(int index, int32_t value) {
  _impl_.data_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:Action.data_i)
}
inline void Action::_internal_add_data_i(int32_t value) {
  _impl_.data_i_.Add(value);
}
inline void Action::add_data_i(int32_t value) {
  _internal_add_data_i(value);
  // @@protoc_insertion_point(field_add:Action.data_i)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::_internal_data_i() const {
  return _impl_.data_i_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::data_i() const {
  // @@protoc_insertion_point(field_list:Action.data_i)
  return _internal_data_i();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::_internal_mutable_data_i() {
  return &_impl_.data_i_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::mutable_data_i() {
  // @@protoc_insertion_point(field_mutable_list:Action.data_i)
  return _internal_mutable_data_i();
}

// repeated int32 shape = 3;
inline int Action::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Action::shape_size() const {
  return _internal_shape_size();
}
inline void Action::clear_shape() {
  _impl_.shape_.Clear();
}
inline int32_t Action::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int32_t Action::shape(int index) const {
  // @@protoc_insertion_point(field_get:Action.shape)
  return _internal_shape(index);
}
inline void Action::set_shape(int index, int32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Action.shape)
}
inline void Action::_internal_add_shape(int32_t value) {
  _impl_.shape_.Add(value);
}
inline void Action::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Action.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Action::shape() const {
  // @@protoc_insertion_point(field_list:Action.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Action::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Action.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// Transition

// .Observation next_observation = 1;
inline bool Transition::_internal_has_next_observation() const {
  return this != internal_default_instance() && _impl_.next_observation_ != nullptr;
}
inline bool Transition::has_next_observation() const {
  return _internal_has_next_observation();
}
inline void Transition::clear_next_observation() {
  if (GetArenaForAllocation() == nullptr && _impl_.next_observation_ != nullptr) {
    delete _impl_.next_observation_;
  }
  _impl_.next_observation_ = nullptr;
}
inline const ::Observation& Transition::_internal_next_observation() const {
  const ::Observation* p = _impl_.next_observation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Observation&>(
      ::_Observation_default_instance_);
}
inline const ::Observation& Transition::next_observation() const {
  // @@protoc_insertion_point(field_get:Transition.next_observation)
  return _internal_next_observation();
}
inline void Transition::unsafe_arena_set_allocated_next_observation(
    ::Observation* next_observation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_observation_);
  }
  _impl_.next_observation_ = next_observation;
  if (next_observation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transition.next_observation)
}
inline ::Observation* Transition::release_next_observation() {
  
  ::Observation* temp = _impl_.next_observation_;
  _impl_.next_observation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Observation* Transition::unsafe_arena_release_next_observation() {
  // @@protoc_insertion_point(field_release:Transition.next_observation)
  
  ::Observation* temp = _impl_.next_observation_;
  _impl_.next_observation_ = nullptr;
  return temp;
}
inline ::Observation* Transition::_internal_mutable_next_observation() {
  
  if (_impl_.next_observation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Observation>(GetArenaForAllocation());
    _impl_.next_observation_ = p;
  }
  return _impl_.next_observation_;
}
inline ::Observation* Transition::mutable_next_observation() {
  ::Observation* _msg = _internal_mutable_next_observation();
  // @@protoc_insertion_point(field_mutable:Transition.next_observation)
  return _msg;
}
inline void Transition::set_allocated_next_observation(::Observation* next_observation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.next_observation_;
  }
  if (next_observation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(next_observation);
    if (message_arena != submessage_arena) {
      next_observation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_observation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_observation_ = next_observation;
  // @@protoc_insertion_point(field_set_allocated:Transition.next_observation)
}

// float reward = 2;
inline void Transition::clear_reward() {
  _impl_.reward_ = 0;
}
inline float Transition::_internal_reward() const {
  return _impl_.reward_;
}
inline float Transition::reward() const {
  // @@protoc_insertion_point(field_get:Transition.reward)
  return _internal_reward();
}
inline void Transition::_internal_set_reward(float value) {
  
  _impl_.reward_ = value;
}
inline void Transition::set_reward(float value) {
  _internal_set_reward(value);
  // @@protoc_insertion_point(field_set:Transition.reward)
}

// bool done = 3;
inline void Transition::clear_done() {
  _impl_.done_ = false;
}
inline bool Transition::_internal_done() const {
  return _impl_.done_;
}
inline bool Transition::done() const {
  // @@protoc_insertion_point(field_get:Transition.done)
  return _internal_done();
}
inline void Transition::_internal_set_done(bool value) {
  
  _impl_.done_ = value;
}
inline void Transition::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:Transition.done)
}

// .StepInfo info = 4;
inline bool Transition::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool Transition::has_info() const {
  return _internal_has_info();
}
inline void Transition::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::StepInfo& Transition::_internal_info() const {
  const ::StepInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::StepInfo&>(
      ::_StepInfo_default_instance_);
}
inline const ::StepInfo& Transition::info() const {
  // @@protoc_insertion_point(field_get:Transition.info)
  return _internal_info();
}
inline void Transition::unsafe_arena_set_allocated_info(
    ::StepInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Transition.info)
}
inline ::StepInfo* Transition::release_info() {
  
  ::StepInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StepInfo* Transition::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Transition.info)
  
  ::StepInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::StepInfo* Transition::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::StepInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::StepInfo* Transition::mutable_info() {
  ::StepInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Transition.info)
  return _msg;
}
inline void Transition::set_allocated_info(::StepInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Transition.info)
}

// -------------------------------------------------------------------

// RenderMode

// string data = 1;
inline void RenderMode::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RenderMode::data() const {
  // @@protoc_insertion_point(field_get:RenderMode.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenderMode::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenderMode.data)
}
inline std::string* RenderMode::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:RenderMode.data)
  return _s;
}
inline const std::string& RenderMode::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RenderMode::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RenderMode::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* RenderMode::release_data() {
  // @@protoc_insertion_point(field_release:RenderMode.data)
  return _impl_.data_.Release();
}
inline void RenderMode::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenderMode.data)
}

// -------------------------------------------------------------------

// RenderOut

// repeated int32 rgb = 1;
inline int RenderOut::_internal_rgb_size() const {
  return _impl_.rgb_.size();
}
inline int RenderOut::rgb_size() const {
  return _internal_rgb_size();
}
inline void RenderOut::clear_rgb() {
  _impl_.rgb_.Clear();
}
inline int32_t RenderOut::_internal_rgb(int index) const {
  return _impl_.rgb_.Get(index);
}
inline int32_t RenderOut::rgb(int index) const {
  // @@protoc_insertion_point(field_get:RenderOut.rgb)
  return _internal_rgb(index);
}
inline void RenderOut::set_rgb(int index, int32_t value) {
  _impl_.rgb_.Set(index, value);
  // @@protoc_insertion_point(field_set:RenderOut.rgb)
}
inline void RenderOut::_internal_add_rgb(int32_t value) {
  _impl_.rgb_.Add(value);
}
inline void RenderOut::add_rgb(int32_t value) {
  _internal_add_rgb(value);
  // @@protoc_insertion_point(field_add:RenderOut.rgb)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RenderOut::_internal_rgb() const {
  return _impl_.rgb_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RenderOut::rgb() const {
  // @@protoc_insertion_point(field_list:RenderOut.rgb)
  return _internal_rgb();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RenderOut::_internal_mutable_rgb() {
  return &_impl_.rgb_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RenderOut::mutable_rgb() {
  // @@protoc_insertion_point(field_mutable_list:RenderOut.rgb)
  return _internal_mutable_rgb();
}

// string ansi = 2;
inline void RenderOut::clear_ansi() {
  _impl_.ansi_.ClearToEmpty();
}
inline const std::string& RenderOut::ansi() const {
  // @@protoc_insertion_point(field_get:RenderOut.ansi)
  return _internal_ansi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenderOut::set_ansi(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ansi_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenderOut.ansi)
}
inline std::string* RenderOut::mutable_ansi() {
  std::string* _s = _internal_mutable_ansi();
  // @@protoc_insertion_point(field_mutable:RenderOut.ansi)
  return _s;
}
inline const std::string& RenderOut::_internal_ansi() const {
  return _impl_.ansi_.Get();
}
inline void RenderOut::_internal_set_ansi(const std::string& value) {
  
  _impl_.ansi_.Set(value, GetArenaForAllocation());
}
inline std::string* RenderOut::_internal_mutable_ansi() {
  
  return _impl_.ansi_.Mutable(GetArenaForAllocation());
}
inline std::string* RenderOut::release_ansi() {
  // @@protoc_insertion_point(field_release:RenderOut.ansi)
  return _impl_.ansi_.Release();
}
inline void RenderOut::set_allocated_ansi(std::string* ansi) {
  if (ansi != nullptr) {
    
  } else {
    
  }
  _impl_.ansi_.SetAllocated(ansi, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ansi_.IsDefault()) {
    _impl_.ansi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenderOut.ansi)
}

// -------------------------------------------------------------------

// EnvSeed

// int32 data = 1;
inline void EnvSeed::clear_data() {
  _impl_.data_ = 0;
}
inline int32_t EnvSeed::_internal_data() const {
  return _impl_.data_;
}
inline int32_t EnvSeed::data() const {
  // @@protoc_insertion_point(field_get:EnvSeed.data)
  return _internal_data();
}
inline void EnvSeed::_internal_set_data(int32_t value) {
  
  _impl_.data_ = value;
}
inline void EnvSeed::set_data(int32_t value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:EnvSeed.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_env_2eproto
